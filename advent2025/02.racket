#lang racket
(require racket/string)

"Hello world"
;(define input "998-1012,10-30")
;(define input "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124")
(define input "1090286-1131879,3259566-3404881,138124-175118,266204727-266361099,16765-24272,7657360692-7657593676,88857504-88926597,6869078-6903096,48444999-48532270,61427792-61580535,71-103,8077-10421,1920-2560,2-17,951-1259,34-50,28994-36978,1309-1822,9393918461-9393960770,89479-120899,834641-988077,5389718924-5389797353,34010076-34214499,5063-7100,607034-753348,19098586-19261191,125085556-125188689,39839-51927,3246-5037,174-260,439715-473176,187287-262190,348-535,58956-78301,4388160-4505757,512092-584994,13388753-13534387")

; split the ranges
(define (splitPairs ran) (string-split ran #rx","))
; take the two numbers from the range, needs a single pair as input
(define (makeTuple s) 
  (string-split s #rx"-"))
; given a tuple, map them to numbers
(define (toNumber pair)
  (map string->number pair))

(define (fullParsePair pair) (toNumber (makeTuple pair)))
(define parsed (map fullParsePair (splitPairs input)))

; range but on tuple & inclusive
(define (rangeTuple p) (range (first p) (add1 (second p))))

(rangeTuple '(10 20))

(define test '(5, 15))
(displayln "LETS TEST")
(define (check num)
  (let* ([numStr (number->string num)]
         [s (string-length numStr)]
         [splitIndex (floor (/ s 2))]
         [a (substring numStr 0 splitIndex)]
         [b (substring numStr splitIndex s)]
         )
    (if (equal? a b) num 0)
  )
)

(apply + (map check (flatten (map rangeTuple parsed))))

;701 too low
